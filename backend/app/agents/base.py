"""
Base agent (abstract base class for all agents).

Overview
  Defines abstract base class for all agents with common interface and
  shared functionality (logging, error handling, state validation).
  Provides dependency injection of LLM client and consistent error handling
  across all agents.

Design
  - **Abstract Interface**: Uses ABC for interface definition.
  - **Dependency Injection**: LLM client injected via constructor.
  - **Error Handling**: Consistent error handling across all agents.
  - **Logging**: Structured logging with context (thread_id, user_id, agent, etc.).
  - **State Validation**: Validates state before processing.

Integration
  - Consumes: app.infrastructure.llm.client.LLMClient, app.contracts.answer.Answer.
  - Returns: Updated GraphState (to be defined in Batch 15).
  - Used by: All agent implementations (Knowledge, Analytics, Commerce, Triage).
  - Observability: Logs processing, errors, and performance metrics.

Usage
  >>> from app.agents.base import BaseAgent
  >>> from app.infrastructure.llm import get_llm_client
  >>> class MyAgent(BaseAgent):
  ...     async def process(self, state: Any) -> Any:
  ...         # Agent-specific implementation
  ...         return state
  >>> agent = MyAgent(get_llm_client(), "my_agent")
"""

import logging
from abc import ABC, abstractmethod
from typing import Any

from app.config.exceptions import ValidationException
from app.contracts.answer import Answer
from app.infrastructure.llm.client import LLMClient

logger = logging.getLogger(__name__)


class BaseAgent(ABC):
    """Abstract base class for all agents.

    Provides common interface and shared functionality for all agents.
    Each agent must implement the abstract `process` method with
    agent-specific logic.

    Attributes:
        name: Agent name (e.g., "knowledge", "analytics").
        llm_client: LLM client (injected via constructor).
        logger: Structured logger for agent operations.
    """

    def __init__(self, llm_client: LLMClient, name: str) -> None:
        """Initialize base agent.

        Stores LLM client and agent name, initializes logger.

        Args:
            llm_client: LLM client for agent operations (required).
            name: Agent name (required, e.g., "knowledge", "analytics").
        """
        self.llm_client = llm_client
        self.name = name
        self.logger = logging.getLogger(f"app.agents.{name}")

    @abstractmethod
    async def process(self, state: Any) -> Any:
        """Process state and return updated state.

        Abstract method that must be implemented by each agent.
        Each agent implements its specific processing logic.

        Args:
            state: Graph state (GraphState - to be defined in Batch 15).

        Returns:
            Updated graph state.

        Note:
            GraphState type will be defined in Batch 15. Currently using
            Any as placeholder.
        """
        pass

    async def _log_processing(
        self,
        state: Any,
        result: Answer,
    ) -> None:
        """Log agent processing with context.

        Logs processing information including thread_id, user_id,
        agent name, query, and performance metrics.

        Args:
            state: Graph state with context.
            result: Answer generated by agent.
        """
        try:
            # Extract context from state (assuming state has these attributes)
            thread_id = getattr(state, "thread_id", None)
            user_id = getattr(state, "user_id", None)
            query = getattr(state, "query", "")

            # Extract performance metrics
            total_time = None
            tokens_used = None
            if result.performance_metrics:
                total_time = result.performance_metrics.total_time_ms
                tokens_used = result.performance_metrics.tokens_used

            # Log with structured context
            log_data = {
                "thread_id": thread_id,
                "user_id": user_id,
                "agent": self.name,
                "query": query[:100] if query else None,  # Truncate for logging
                "response_length": len(result.text),
                "language": result.language,
                "total_time_ms": total_time,
                "tokens_used": tokens_used,
            }

            self.logger.info(
                f"Agent {self.name} processed query",
                extra=log_data,
            )
        except Exception as e:
            # Don't fail processing if logging fails
            self.logger.warning(
                f"Failed to log processing: {e}",
                exc_info=True,
            )

    async def _handle_error(
        self,
        error: Exception,
        state: Any,
    ) -> Any:
        """Handle error during processing.

        Logs error with full context and updates state with error information.
        Returns state with error response.

        Args:
            error: Exception that occurred.
            state: Graph state.

        Returns:
            Updated state with error information.
        """
        try:
            # Extract context from state
            thread_id = getattr(state, "thread_id", None)
            user_id = getattr(state, "user_id", None)
            query = getattr(state, "query", "")

            # Log error with context
            self.logger.error(
                f"Agent {self.name} processing error: {str(error)}",
                extra={
                    "thread_id": thread_id,
                    "user_id": user_id,
                    "agent": self.name,
                    "query": query[:100] if query else None,
                    "error_type": type(error).__name__,
                    "error_message": str(error),
                },
                exc_info=True,
            )

            # Create error answer
            error_answer = Answer(
                text=f"Desculpe, ocorreu um erro ao processar sua solicitação: {str(error)}",
                agent=self.name,
                language=getattr(state, "language", "pt-BR"),
            )

            # Update state with error (assuming state has agent_response attribute)
            if hasattr(state, "agent_response"):
                state.agent_response = error_answer
            else:
                # If state doesn't have agent_response, create a new state-like object
                # This is a temporary solution until GraphState is defined
                setattr(state, "agent_response", error_answer)

            return state
        except Exception as e:
            # If error handling itself fails, log and return state as-is
            self.logger.critical(
                f"Critical error in error handler: {e}",
                exc_info=True,
            )
            return state

    def _validate_state(self, state: Any) -> None:
        """Validate state before processing.

        Validates that state has required fields (query, thread_id, etc.).
        Raises ValidationException if state is invalid.

        Args:
            state: Graph state to validate.

        Raises:
            ValidationException: If state is invalid (missing required fields).
        """
        if state is None:
            raise ValidationException(
                message="State cannot be None",
                details={"agent": self.name},
            )

        # Validate required fields (assuming state has these attributes)
        required_fields = ["query", "thread_id"]

        for field in required_fields:
            if not hasattr(state, field):
                raise ValidationException(
                    message=f"State missing required field: {field}",
                    details={"agent": self.name, "field": field},
                )

            value = getattr(state, field)
            if value is None or (isinstance(value, str) and not value.strip()):
                raise ValidationException(
                    message=f"State field {field} cannot be empty",
                    details={"agent": self.name, "field": field},
                )

